{"version":3,"file":"index.mjs","sources":["../lib/inverse_students_t_body_series.js","../lib/polyval_co14.js","../lib/polyval_co15.js","../lib/polyval_co16.js","../lib/polyval_co17.js","../lib/polyval_co18.js","../lib/polyval_co19.js","../lib/polyval_co20.js","../lib/polyval_co21.js","../lib/polyval_co22.js","../lib/inverse_students_t_tail_series.js","../lib/inverse_students_t_hill.js","../lib/inverse_students_t.js","../lib/find_ibeta_inv_from_t_dist.js","../lib/temme1.js","../lib/root_finder.js","../lib/newton_raphson.js","../lib/temme2.js","../lib/main.js","../lib/polyval_co1.js","../lib/polyval_co2.js","../lib/polyval_co3.js","../lib/polyval_co4.js","../lib/polyval_co5.js","../lib/polyval_co6.js","../lib/polyval_co7.js","../lib/polyval_co8.js","../lib/polyval_co9.js","../lib/polyval_co10.js","../lib/polyval_co11.js","../lib/polyval_co12.js","../lib/polyval_co13.js","../lib/temme3.js","../lib/ibeta_roots.js","../lib/halley_iterate.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/detail/t_distribution_inv.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport gammaDeltaRatio from '@stdlib/math-base-special-gamma-delta-ratio';\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport PI from '@stdlib/constants-float64-pi';\nimport polyval1 from './polyval_co14.js';\nimport polyval2 from './polyval_co15.js';\nimport polyval3 from './polyval_co16.js';\nimport polyval4 from './polyval_co17.js';\nimport polyval5 from './polyval_co18.js';\nimport polyval6 from './polyval_co19.js';\nimport polyval7 from './polyval_co20.js';\nimport polyval8 from './polyval_co21.js';\nimport polyval9 from './polyval_co22.js';\n\n\n// VARIABLES //\n\nvar c0 = 0.0;\n\n// Workspace for the polynomial coefficients:\nvar c = [ 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Evaluates Student's t quantiles via a body series expansion. Tail and body series are due to Shaw.\n*\n* ## References\n*\n* -   Shaw, William T. 2006. \"Sampling Student's T distribution – use of the inverse cumulative distribution function.\" _Journal of Computational Finance_ 9 (4): 37–73. [www.mth.kcl.ac.uk/~shaww/web\\_page/papers/Tdistribution06.pdf](www.mth.kcl.ac.uk/~shaww/web_page/papers/Tdistribution06.pdf).\n*\n* @private\n* @param {PositiveNumber} df - degrees of freedom\n* @param {Probability} u - input probability\n* @returns {number} function value\n*/\nfunction inverseStudentsTBodySeries( df, u ) {\n\tvar idf;\n\tvar v;\n\n\t// Body series for small N, start with Eq 56 of Shaw:\n\tv = gammaDeltaRatio( df/2, 0.5 ) * sqrt( df*PI ) * ( u-0.5 );\n\n\t// Figure out what the coefficients are. They depend only on the degrees of freedom (Eq 57 of Shaw):\n\tidf = 1.0 / df;\n\tc[ 1 ] = polyval1( idf );\n\tc[ 2 ] = polyval2( idf );\n\tc[ 3 ] = polyval3( idf );\n\tc[ 4 ] = polyval4( idf );\n\tc[ 5 ] = polyval5( idf );\n\tc[ 6 ] = polyval6( idf );\n\tc[ 7 ] = polyval7( idf );\n\tc[ 8 ] = polyval8( idf );\n\tc[ 9 ] = polyval9( idf );\n\n\t// Result is then an odd polynomial in v (see Eq 56 of Shaw)...\n\treturn c0 + ( v*evalpoly( c, v*v ) );\n}\n\n\n// EXPORTS //\n\nexport default inverseStudentsTBodySeries;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.16666666666666666;\n\t}\n\treturn 0.16666666666666666 + (x * 0.16666666666666666);\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.058333333333333334;\n\t}\n\treturn 0.058333333333333334 + (x * (0.06666666666666667 + (x * 0.008333333333333333))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.0251984126984127;\n\t}\n\treturn 0.0251984126984127 + (x * (0.026785714285714284 + (x * (0.0017857142857142857 + (x * 0.0001984126984126984))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.012039792768959435;\n\t}\n\treturn 0.012039792768959435 + (x * (0.010559964726631394 + (x * (-0.0011078042328042327 + (x * (0.0003747795414462081 + (x * 0.0000027557319223985893))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.003837005972422639;\n\t}\n\treturn 0.003837005972422639 + (x * (0.00610392115600449 + (x * (-0.0016095979637646305 + (x * (0.0005945867404200738 + (x * (-0.00006270542728876062 + (x * 2.505210838544172e-8))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.0032177478835464946;\n\t}\n\treturn 0.0032177478835464946 + (x * (0.0010898206731540065 + (x * (-0.0012579159844784845 + (x * (0.0006908420797309686 + (x * (-0.00016376804137220805 + (x * (0.0000154012654012654 + (x * 1.6059043836821613e-10))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.001743826229834001;\n\t}\n\treturn 0.001743826229834001 + (x * (0.00003353097688001788 + (x * (-0.0007624513544032393 + (x * (0.0006451304695145635 + (x * (-0.000249472580470431 + (x * (0.000049255746366361444 + (x * (-0.0000039851014346715405 + (x * 7.647163731819816e-13))))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.0009647274732138864;\n\t}\n\treturn 0.0009647274732138864 + (x * (-0.0003110108632631878 + (x * (-0.00036307660358786886 + (x * (0.0005140660578834113 + (x * (-0.00029133414466938067 + (x * (0.00009086710793521991 + (x * (-0.000015303004486655377 + (x * (0.0000010914179173496788 + (x * 2.8114572543455206e-15))))))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 0.0005422926281312969;\n\t}\n\treturn 0.0005422926281312969 + (x * (-0.0003694266780000966 + (x * (-0.00010230378073700413 + (x * (0.00035764655430568635 + (x * (-0.00028690924218514614 + (x * (0.00012645437628698076 + (x * (-0.000033202652391372056 + (x * (0.000004890304529197534 + (x * (-3.123956959982987e-7 + (x * 8.22063524662433e-18))))))))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/t_distribution_inv.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport gammaDeltaRatio from '@stdlib/math-base-special-gamma-delta-ratio';\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport pow from '@stdlib/math-base-special-pow';\nimport PI from '@stdlib/constants-float64-pi';\n\n\n// VARIABLES //\n\n// Array for the coefficients d(k), these depend only on the number of degrees of freedom df, so at least in theory we could tabulate these for fixed df, see p15 of Shaw:\nvar d = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Evaluates Student's t quantiles via a tail series expansion. Tail and body series are due to Shaw.\n*\n* ## References\n*\n* -   Shaw, William T. 2006. \"Sampling Student's T distribution – use of the inverse cumulative distribution function.\" _Journal of Computational Finance_ 9 (4): 37–73. [www.mth.kcl.ac.uk/~shaww/web\\_page/papers/Tdistribution06.pdf](www.mth.kcl.ac.uk/~shaww/web_page/papers/Tdistribution06.pdf).\n*\n* @private\n* @param {number} df - degrees of freedom\n* @param {number} v - function value\n* @returns {number} tail value\n*/\nfunction inverseStudentsTTailSeries( df, v ) { // eslint-disable-line id-length\n\tvar result;\n\tvar power;\n\tvar div;\n\tvar np2;\n\tvar np4;\n\tvar np6;\n\tvar rn;\n\tvar w;\n\n\t// Tail series expansion, see section 6 of Shaw's paper. `w` is calculated using Eq 60:\n\tw = gammaDeltaRatio( df/2.0, 0.5 ) * sqrt( df*PI ) * v;\n\n\t// Define some variables:\n\tnp2 = df + 2.0;\n\tnp4 = df + 4.0;\n\tnp6 = df + 6.0;\n\n\td[ 0 ] = 1.0;\n\td[ 1 ] = -(df+1.0) / (2.0*np2);\n\tnp2 *= (df + 2.0);\n\td[ 2 ] = -df * (df+1.0) * (df+3.0) / (8.0*np2*np4);\n\tnp2 *= df + 2.0;\n\td[ 3 ] = -df * (df+1.0) * (df+5.0) * (((3.0*df) + 7.0) * df - 2.0) / (48.0*np2*np4*np6); // eslint-disable-line max-len, no-mixed-operators\n\tnp2 *= (df + 2.0);\n\tnp4 *= (df + 4.0);\n\td[ 4 ] = -df * (df+1.0) * (df+7.0) * ( (((((15.0*df) + 154.0) * df + 465.0) * df + 286.0) * df - 336.0) * df + 64.0) / (384.0*np2*np4*np6*(df+8.0)); // eslint-disable-line max-len, no-mixed-operators\n\tnp2 *= (df + 2.0);\n\td[ 5 ] = -df * (df+1.0) * (df+3.0) * (df+9.0) * (((((((35.0 * df + 452.0) * df+1573.0) * df + 600.0) * df - 2020.0) * df) + 928.0) * df - 128.0) / (1280.0*np2*np4*np6*(df+8.0) * (df+10.0)); // eslint-disable-line max-len, no-mixed-operators\n\tnp2 *= (df + 2.0);\n\tnp4 *= (df + 4.0);\n\tnp6 *= (df + 6.0);\n\td[ 6 ] = -df * (df+1.0) * (df+11.0) * ((((((((((((945.0*df) + 31506.0) * df + 425858.0) * df + 2980236.0) * df + 11266745.0) * df + 20675018.0) * df + 7747124.0) * df - 22574632.0) * df - 8565600.0) * df + 18108416.0) * df - 7099392.0) * df + 884736.0) / (46080.0*np2*np4*np6*(df+8.0) * (df+10.0) * (df+12.0)); // eslint-disable-line max-len, no-mixed-operators\n\n\t// Now bring everything together to provide the result this is Eq 62 of Shaw:\n\trn = sqrt( df );\n\tdiv = pow( rn*w, 1.0/df );\n\tpower = div * div;\n\tresult = evalpoly( d, power );\n\tresult *= rn;\n\tresult /= div;\n\treturn -result;\n}\n\n\n// EXPORTS //\n\nexport default inverseStudentsTTailSeries;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/t_distribution_inv.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n/* eslint-disable no-mixed-operators */\n\n'use strict';\n\n// MODULES //\n\nimport erfcinv from '@stdlib/math-base-special-erfcinv';\nimport expm1 from '@stdlib/math-base-special-expm1';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport pow from '@stdlib/math-base-special-pow';\nimport HALF_PI from '@stdlib/constants-float64-half-pi';\nimport SQRT2 from '@stdlib/constants-float64-sqrt-two';\n\n\n// MAIN //\n\n/**\n* Evaluates Student's t quantiles via a method due to Hill.\n*\n* ## References\n*\n* -   Hill, G. W. 1970. \"Algorithm 396: Student's T-Quantiles.\" _Communications of the ACM_ 13 (10). New York, NY, USA: ACM: 619–20. doi:[10.1145/355598.355600](https://doi.org/10.1145/355598.355600).\n*\n* @private\n* @param {PositiveNumber} ndf - degrees of freedom\n* @param {Probability} u - input probability\n* @returns {number} function value\n*/\nfunction inverseStudentsTHill( ndf, u ) {\n\tvar a;\n\tvar b;\n\tvar c;\n\tvar d;\n\tvar q;\n\tvar x;\n\tvar y;\n\n\tif ( ndf > 1e20 ) {\n\t\treturn -erfcinv( 2 * u ) * SQRT2;\n\t}\n\ta = 1.0 / ( ndf - 0.5 );\n\tb = 48.0 / (a * a);\n\tc = ( ( ( ( (20700.0*a/b) - 98.0 ) * a ) - 16.0 ) * a ) + 96.36;\n\td = ( ( ( (94.5/(b+c)) - 3.0 ) / b ) + 1.0 ) * sqrt( a * HALF_PI ) * ndf;\n\ty = pow( d * 2.0 * u, 2.0 / ndf );\n\n\tif ( y > ( 0.05 + a ) ) {\n\t\t// Asymptotic inverse expansion about normal:\n\t\tx = -erfcinv( 2.0 * u ) * SQRT2;\n\t\ty = x * x;\n\n\t\tif ( ndf < 5.0 ) {\n\t\t\tc += 0.3 * ( ndf-4.5 ) * ( x + 0.6 );\n\t\t}\n\t\tc += ( ( ( ( ( ( (0.05*d*x)-5.0 ) * x ) - 7.0 ) * x )- 2.0 ) * x ) + b;\n\t\ty = ((((((0.4*y+6.3)*y)+36.0) * y + 94.5) / c - y - 3.0) / b + 1.0) * x;\n\t\ty = expm1( a * y * y );\n\t} else {\n\t\ty = ((1.0 / ( ( (ndf+6.0) / (ndf*y) - 0.089 * d - 0.822 ) *\n\t\t(ndf+2.0) * 3.0 ) + 0.5 / (ndf+4.0)) * y - 1.0) *\n\t\t(ndf+1.0) / (ndf+2.0) + 1.0 / y;\n\t}\n\tq = sqrt( ndf * y );\n\treturn -q;\n}\n\n\n// EXPORTS //\n\nexport default inverseStudentsTHill;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/detail/t_distribution_inv.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport erfcinv from '@stdlib/math-base-special-erfcinv';\nimport floor from '@stdlib/math-base-special-floor';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport round from '@stdlib/math-base-special-round';\nimport acos from '@stdlib/math-base-special-acos';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport abs from '@stdlib/math-base-special-abs';\nimport cos from '@stdlib/math-base-special-cos';\nimport pow from '@stdlib/math-base-special-pow';\nimport sin from '@stdlib/math-base-special-sin';\nimport SQRT2 from '@stdlib/constants-float64-sqrt-two';\nimport PI from '@stdlib/constants-float64-pi';\nimport inverseStudentsTBodySeries from './inverse_students_t_body_series.js';\nimport inverseStudentsTTailSeries from './inverse_students_t_tail_series.js';\nimport inverseStudentsTHill from './inverse_students_t_hill.js';\n\n\n// VARIABLES //\n\nvar DF_THRESHOLD = 0x10000000; // 2^28\nvar ONE_THIRD = 1.0 / 3.0;\nvar EXP = ( 2.0 * 53.0 ) / 3.0;\nvar C = 0.85498797333834849467655443627193;\n\n\n// MAIN //\n\n/**\n* Evaluates Student's t quantiles.\n*\n* @private\n* @param {PositiveNumber} df - degrees of freedom\n* @param {Probability} u - input probability\n* @param {Probability} v - probability equal to `1-u`\n* @returns {number} function value\n*/\nfunction inverseStudentsT( df, u, v ) {\n\tvar crossover;\n\tvar tolerance;\n\tvar rootAlpha;\n\tvar invert;\n\tvar result;\n\tvar alpha;\n\tvar tmp;\n\tvar p0;\n\tvar p2;\n\tvar p4;\n\tvar p5;\n\tvar p;\n\tvar r;\n\tvar x;\n\tvar a;\n\tvar b;\n\n\tresult = 0;\n\tif ( u > v ) {\n\t\t// Function is symmetric, so invert it:\n\t\ttmp = v;\n\t\tv = u;\n\t\tu = tmp;\n\t\tinvert = true;\n\t} else {\n\t\tinvert = false;\n\t}\n\tif ( floor(df) === df && df < 20 ) {\n\t\t// We have integer degrees of freedom, try for the special cases first:\n\t\ttolerance = ldexp( 1.0, EXP );\n\n\t\tswitch ( floor( df ) ) {\n\t\tcase 1:\n\t\t\t// `df = 1` is the same as the Cauchy distribution, see Shaw Eq 35:\n\t\t\tif ( u === 0.5 ) {\n\t\t\t\tresult = 0.0;\n\t\t\t} else {\n\t\t\t\tresult = -cos( PI * u ) / sin( PI * u );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t// `df = 2` has an exact result, see Shaw Eq 36:\n\t\t\tresult = ( (2.0*u) - 1.0 ) / sqrt( 2.0 * u * v );\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t// `df = 4` has an exact result, see Shaw Eq 38 & 39:\n\t\t\talpha = 4.0 * u * v;\n\t\t\trootAlpha = sqrt( alpha );\n\t\t\tr = 4 * cos( acos( rootAlpha ) / 3.0 ) / rootAlpha;\n\t\t\tx = sqrt( r - 4.0 );\n\t\t\tresult = ( u - 0.5 < 0.0 ) ? -x : x;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t// We get numeric overflow in this area:\n\t\t\tif ( u < 1.0e-150 ) {\n\t\t\t\treturn ( ( invert ) ? -1 : 1 ) * inverseStudentsTHill( df, u );\n\t\t\t}\n\t\t\t// Newton-Raphson iteration of a polynomial case, choice of seed value is taken from Shaw's online supplement:\n\t\t\ta = 4.0 * ( u - (u*u) ); // 1 - 4 * (u - 0.5f) * (u - 0.5f);\n\t\t\tb = pow( a, ONE_THIRD );\n\t\t\tp = 6.0 * ( 1.0 + ( C * ( (1.0/b) - 1.0 ) ) );\n\t\t\tdo {\n\t\t\t\tp2 = p * p;\n\t\t\t\tp4 = p2 * p2;\n\t\t\t\tp5 = p * p4;\n\t\t\t\tp0 = p;\n\n\t\t\t\t// Next term is given by Eq 41:\n\t\t\t\tp = 2.0 * ( (8.0*a*p5) - (270.0*p2) + 2187 ) /\n\t\t\t\t\t( 5.0 * ( (4.0*a*p4) - (216.0*p) - 243.0 ) );\n\t\t\t} while ( abs( (p - p0) / p ) > tolerance );\n\n\t\t\t// Use Eq 45 to extract the result:\n\t\t\tp = sqrt( p - df );\n\t\t\tresult = ( u - 0.5 < 0.0 ) ? -p : p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( df > DF_THRESHOLD ) { // 2^28\n\t\t\t\tresult = erfcinv( 2.0 * u ) * SQRT2;\n\t\t\t} else if ( df < 3 ) {\n\t\t\t\t// Use a roughly linear scheme to choose between Shaw's tail series and body series:\n\t\t\t\tcrossover = 0.2742 - ( df * 0.0242143 );\n\t\t\t\tif ( u > crossover ) {\n\t\t\t\t\tresult = inverseStudentsTBodySeries( df, u );\n\t\t\t\t} else {\n\t\t\t\t\tresult = inverseStudentsTTailSeries( df, u );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Use Hill's method except in the extreme tails where we use Shaw's tail series. The crossover point is roughly exponential in -df:\n\t\t\t\tcrossover = ldexp( 1.0, round( df / -0.654 ) );\n\t\t\t\tif ( u > crossover ) {\n\t\t\t\t\tresult = inverseStudentsTHill( df, u );\n\t\t\t\t} else {\n\t\t\t\t\tresult = inverseStudentsTTailSeries( df, u );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if ( df > DF_THRESHOLD ) {\n\t\tresult = -erfcinv( 2.0 * u ) * SQRT2;\n\t} else if ( df < 3 ) {\n\t\t// Use a roughly linear scheme to choose between Shaw's tail series and body series:\n\t\tcrossover = 0.2742 - ( df * 0.0242143 );\n\t\tif ( u > crossover ) {\n\t\t\tresult = inverseStudentsTBodySeries( df, u );\n\t\t} else {\n\t\t\tresult = inverseStudentsTTailSeries( df, u );\n\t\t}\n\t} else {\n\t\t// Use Hill's method except in the extreme tails where we use Shaw's tail series. The crossover point is roughly exponential in -df:\n\t\tcrossover = ldexp( 1.0, round( df / -0.654 ) );\n\t\tif ( u > crossover ) {\n\t\t\tresult = inverseStudentsTHill( df, u );\n\t\t} else {\n\t\t\tresult = inverseStudentsTTailSeries( df, u );\n\t\t}\n\t}\n\treturn ( invert ) ? -result : result;\n}\n\n\n// EXPORTS //\n\nexport default inverseStudentsT;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/detail/t_distribution_inv.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport inverseStudentsT from './inverse_students_t.js';\n\n\n// MAIN //\n\n/**\n* Returns the inverse of the incomplete beta function via the Student t distribution.\n*\n* @private\n* @param {PositiveNumber} a - function parameter\n* @param {Probability} p - probability value\n* @param {Object} py - placeholder object holding one minus the returned value\n* @returns {number} function value\n*/\nfunction findIBetaInvFromTDist( a, p, py ) {\n\tvar df;\n\tvar u;\n\tvar v;\n\tvar t;\n\n\tu = p / 2.0;\n\tv = 1.0 - u;\n\tdf = a * 2.0;\n\tt = inverseStudentsT( df, u, v );\n\tif ( py ) {\n\t\tpy.value = t * t / ( df + ( t*t ) );\n\t}\n\treturn df / ( df + ( t*t ) );\n}\n\n\n// EXPORTS //\n\nexport default findIBetaInvFromTDist;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport erfcinv from '@stdlib/math-base-special-erfcinv';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport exp from '@stdlib/math-base-special-exp';\nimport SQRT2 from '@stdlib/constants-float64-sqrt-two';\n\n\n// VARIABLES //\n\n// Workspaces for the polynomial coefficients:\nvar workspace = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];\nvar terms = [ 0.0, 0.0, 0.0, 0.0 ];\n\n\n// MAIN //\n\n/**\n* Carries out the first method by Temme (described in section 2).\n*\n* ## References\n*\n* -   Temme, N. M. 1992. \"Incomplete Laplace Integrals: Uniform Asymptotic Expansion with Application to the Incomplete Beta Function.\" _Journal of Computational and Applied Mathematics_ 41 (1–2): 1638–63. doi:[10.1016/0377-0427(92)90244-R](https://doi.org/10.1016/0377-0427(92)90244-R).\n*\n* @private\n* @param {PositiveNumber} a - function parameter\n* @param {PositiveNumber} b - function parameter\n* @param {Probability} z - function parameter\n* @returns {number} function value\n*/\nfunction temme1( a, b, z ) {\n\tvar eta0;\n\tvar eta2;\n\tvar eta;\n\tvar B2;\n\tvar B3;\n\tvar B;\n\tvar c;\n\n\t// Get the first approximation for eta from the inverse error function (Eq: 2.9 and 2.10):\n\teta0 = erfcinv( 2.0 * z );\n\teta0 /= -sqrt( a / 2.0 );\n\n\tterms[ 0 ] = eta0;\n\n\t// Calculate powers:\n\tB = b - a;\n\tB2 = B * B;\n\tB3 = B2 * B;\n\n\t// Calculate correction terms:\n\n\t// See eq following 2.15:\n\tworkspace[ 0 ] = -B * SQRT2 / 2;\n\tworkspace[ 1 ] = ( 1 - (2.0*B) ) / 8.0;\n\tworkspace[ 2 ] = -(B * SQRT2 / 48.0);\n\tworkspace[ 3 ] = -1.0 / 192.0;\n\tworkspace[ 4 ] = -B * SQRT2 / 3840.0;\n\tworkspace[ 5 ] = 0.0;\n\tworkspace[ 6 ] = 0.0;\n\tterms[ 1 ] = evalpoly( workspace, eta0 );\n\n\t// Eq Following 2.17:\n\tworkspace[ 0 ] = B * SQRT2 * ( (3.0*B) - 2.0) / 12.0;\n\tworkspace[ 1 ] = ( (20.0*B2) - (12.0*B) + 1.0 ) / 128.0;\n\tworkspace[ 2 ] = B * SQRT2 * ( (20.0*B) - 1.0) / 960.0;\n\tworkspace[ 3 ] = ( (16.0*B2) + (30.0*B) - 15.0) / 4608.0;\n\tworkspace[ 4 ] = B * SQRT2 * ( (21.0*B) + 32) / 53760.0;\n\tworkspace[ 5 ] = (-(32.0*B2) + 63.0) / 368640.0;\n\tworkspace[ 6 ] = -B * SQRT2 * ( (120.0*B) + 17.0) / 25804480.0;\n\tterms[ 2 ] = evalpoly( workspace, eta0 );\n\n\t// Eq Following 2.17:\n\tworkspace[ 0 ] = B * SQRT2 * ( (-75*B2) + (80.0*B) - 16.0) / 480.0;\n\tworkspace[ 1 ] = ( (-1080.0*B3) + (868.0*B2) - (90.0*B) - 45.0) / 9216.0;\n\tworkspace[ 2 ] = B * SQRT2 * ( (-1190.0*B2) + (84.0*B) + 373.0) / 53760.0;\n\tworkspace[ 3 ] = ( (-2240.0*B3)-(2508.0*B2)+(2100.0*B)-165.0 ) / 368640.0;\n\tworkspace[ 4 ] = 0.0;\n\tworkspace[ 5 ] = 0.0;\n\tworkspace[ 6 ] = 0.0;\n\tterms[ 3 ] = evalpoly( workspace, eta0 );\n\n\t// Bring them together to get a final estimate for eta:\n\teta = evalpoly( terms, 1.0/a );\n\n\t// Now we need to convert eta to the return value `x`, by solving the appropriate quadratic equation:\n\teta2 = eta * eta;\n\tc = -exp( -eta2 / 2.0 );\n\tif ( eta2 === 0.0 ) {\n\t\treturn 0.5;\n\t}\n\treturn ( 1.0 + ( eta * sqrt( ( 1.0+c ) / eta2 ) ) ) / 2.0;\n}\n\n\n// EXPORTS //\n\nexport default temme1;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport ln from '@stdlib/math-base-special-ln';\nimport MAX_VALUE from '@stdlib/constants-float64-max';\n\n\n// VARIABLES //\n\nvar BIG = MAX_VALUE / 4.0;\n\n\n// MAIN //\n\n/**\n* Helper function used by root finding code to convert `eta` to `x`.\n*\n* @private\n* @param {number} t - first parameter\n* @param {number} a - second parameter\n* @returns {Function} root function\n*/\nfunction temmeRootFinder( t, a ) {\n\treturn roots;\n\n\t/**\n\t* Calculates roots.\n\t*\n\t* @private\n\t* @param {number} x - function value\n\t* @returns {Array} function roots\n\t*/\n\tfunction roots( x ) {\n\t\tvar f1;\n\t\tvar f;\n\t\tvar y;\n\n\t\ty = 1.0 - x;\n\t\tif ( y === 0.0 ) {\n\t\t\treturn [ -BIG, -BIG ];\n\t\t}\n\t\tif ( x === 0.0 ) {\n\t\t\treturn [ -BIG, -BIG ];\n\t\t}\n\t\tf = ln( x ) + ( a * ln( y ) ) + t;\n\t\tf1 = ( 1.0 / x ) - ( a / y );\n\t\treturn [ f, f1 ];\n\t}\n}\n\n\n// EXPORTS //\n\nexport default temmeRootFinder;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/tools/roots.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport sign from '@stdlib/math-base-special-signum';\nimport abs from '@stdlib/math-base-special-abs';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport MAX_VALUE from '@stdlib/constants-float64-max';\n\n\n// MAIN //\n\n/**\n* Performs root finding via second order Newton-Raphson iteration.\n*\n* @private\n* @param {Array} fun - two-element array of the function and its first derivative\n* @param {number} guess - initial starting value.\n* @param {number} min - minimum possible value for the result,used as initial lower bracket.\n* @param {number} max - maximum possible value for the result, used as initial upper bracket.\n* @param {PositiveInteger} digits - desired number of binary digits\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} function value\n*/\nfunction newtonRaphsonIterate( fun, guess, min, max, digits, maxIter ) {\n\tvar f0last;\n\tvar delta1;\n\tvar delta2;\n\tvar factor;\n\tvar result;\n\tvar count;\n\tvar delta;\n\tvar res;\n\tvar f0;\n\tvar f1;\n\n\tf0 = 0.0;\n\tf0last = 0.0;\n\tresult = guess;\n\n\tfactor = ldexp( 1.0, 1.0 - digits );\n\tdelta = MAX_VALUE;\n\tdelta1 = MAX_VALUE;\n\tdelta2 = MAX_VALUE;\n\n\tcount = maxIter;\n\tdo {\n\t\tf0last = f0;\n\t\tdelta2 = delta1;\n\t\tdelta1 = delta;\n\t\tres = fun(result);\n\t\tf0 = res[ 0 ];\n\t\tf1 = res[ 1 ];\n\t\tcount -= 1;\n\t\tif ( f0 === 0.0 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( f1 === 0.0 ) {\n\t\t\t// Oops zero derivative!!!\n\t\t\tif ( f0last === 0.0 ) {\n\t\t\t\t// Must be the first iteration, pretend that we had a previous one at either min or max:\n\t\t\t\tif ( result === min ) {\n\t\t\t\t\tguess = max;\n\t\t\t\t} else {\n\t\t\t\t\tguess = min;\n\t\t\t\t}\n\t\t\t\tf0last = fun( guess );\n\t\t\t\tdelta = guess - result;\n\t\t\t}\n\t\t\tif ( sign(f0last) * sign(f0) < 0 ) {\n\t\t\t\t// We've crossed over so move in opposite direction to last step:\n\t\t\t\tif ( delta < 0 ) {\n\t\t\t\t\tdelta = (result - min) / 2.0;\n\t\t\t\t} else {\n\t\t\t\t\tdelta = (result - max) / 2.0;\n\t\t\t\t}\n\t\t\t} else if ( delta < 0 ) {\n\t\t\t\tdelta = (result - max) / 2.0;\n\t\t\t} else {\n\t\t\t\tdelta = (result - min) / 2.0;\n\t\t\t}\n\t\t} else {\n\t\t\tdelta = f0 / f1;\n\t\t}\n\t\tif ( abs(delta * 2.0) > abs(delta2) ) {\n\t\t\t// Last two steps haven't converged, try bisection:\n\t\t\tdelta = ( delta > 0.0 ) ? (result-min) / 2.0 : (result-max) / 2.0;\n\t\t}\n\t\tguess = result;\n\t\tresult -= delta;\n\t\tif ( result <= min ) {\n\t\t\tdelta = 0.5 * (guess - min);\n\t\t\tresult = guess - delta;\n\t\t\tif ( result === min || result === max ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ( result >= max ) {\n\t\t\tdelta = 0.5 * (guess - max);\n\t\t\tresult = guess - delta;\n\t\t\tif ( result === min || result === max ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Update brackets:\n\t\tif ( delta > 0.0 ) {\n\t\t\tmax = guess;\n\t\t} else {\n\t\t\tmin = guess;\n\t\t}\n\t}\n\twhile ( count && ( abs(result * factor) < abs(delta) ) );\n\n\treturn result;\n}\n\n\n// EXPORTS //\n\nexport default newtonRaphsonIterate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport erfcinv from '@stdlib/math-base-special-erfcinv';\nimport abs from '@stdlib/math-base-special-abs';\nimport exp from '@stdlib/math-base-special-exp';\nimport ln from '@stdlib/math-base-special-ln';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport sin from '@stdlib/math-base-special-sin';\nimport cos from '@stdlib/math-base-special-cos';\nimport temmeRootFinder from './root_finder.js';\nimport newtonRaphsonIterate from './newton_raphson.js';\nimport polyval1 from './polyval_co1.js';\nimport polyval2 from './polyval_co2.js';\nimport polyval3 from './polyval_co3.js';\nimport polyval4 from './polyval_co4.js';\nimport polyval5 from './polyval_co5.js';\nimport polyval6 from './polyval_co6.js';\nimport polyval7 from './polyval_co7.js';\nimport polyval8 from './polyval_co8.js';\nimport polyval9 from './polyval_co9.js';\nimport polyval10 from './polyval_co10.js';\nimport polyval11 from './polyval_co11.js';\nimport polyval12 from './polyval_co12.js';\nimport polyval13 from './polyval_co13.js';\n\n\n// VARIABLES //\n\n// Workspaces for polynomial coefficients:\nvar workspace = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];\nvar terms = [ 0.0, 0.0, 0.0, 0.0 ];\n\n\n// MAIN //\n\n/**\n* Carries out the second method by Temme (described in section 3).\n*\n* ## References\n*\n* -   Temme, N. M. 1992. \"Incomplete Laplace Integrals: Uniform Asymptotic Expansion with Application to the Incomplete Beta Function.\" _Journal of Computational and Applied Mathematics_ 41 (1–2): 1638–63. doi:[10.1016/0377-0427(92)90244-R](https://doi.org/10.1016/0377-0427(92)90244-R).\n*\n* @private\n* @param {number} z - function parameter\n* @param {number} r - function parameter\n* @param {number} theta - function parameter\n* @returns {number} function value\n*/\nfunction temme2( z, r, theta ) {\n\tvar upper;\n\tvar lower;\n\tvar alpha;\n\tvar roots;\n\tvar eta0;\n\tvar eta;\n\tvar sc7;\n\tvar sc6;\n\tvar sc5;\n\tvar sc4;\n\tvar sc3;\n\tvar sc2;\n\tvar sc;\n\tvar lu;\n\tvar s2;\n\tvar c2;\n\tvar c;\n\tvar s;\n\tvar u;\n\tvar x;\n\n\t// Get first estimate for eta, see Eq 3.9 and 3.10, but note there is a typo in Eq 3.10:\n\teta0 = erfcinv( 2.0*z ) / (-sqrt( r/2.0 ));\n\n\ts = sin( theta );\n\tc = cos( theta );\n\n\t// Now we need to perturb eta0 to get eta, which we do by evaluating the polynomial in 1/r at the bottom of page 151, to do this we first need the error terms e1, e2 e3 which we'll fill into the array \"terms\".  Since these terms are themselves polynomials, we'll need another array \"workspace\" to calculate those...\n\tterms[ 0 ] = eta0;\n\n\t// Some powers of sin(theta) cos(theta) that we'll need later:\n\ts2 = s * s;\n\tc2 = c * c;\n\tsc = s * c;\n\tsc2 = sc * sc;\n\tsc3 = sc2 * sc;\n\tsc4 = sc2 * sc2;\n\tsc5 = sc2 * sc3;\n\tsc6 = sc3 * sc3;\n\tsc7 = sc4 * sc3;\n\n\t// Calculate e1 and put it in terms[1], see the middle of page 151:\n\tworkspace[ 0 ] = ((2.0*s2) - 1.0) / ( 3.0*sc );\n\tworkspace[ 1 ] = -polyval1( s2 ) / (36.0*sc2);\n\tworkspace[ 2 ] = polyval2( s2 ) / (1620.0*sc3);\n\tworkspace[ 3 ] = polyval3( s2 ) / (6480.0*sc4);\n\tworkspace[ 4 ] = polyval4( s2 ) / (90720.0*sc5);\n\tworkspace[ 5 ] = 0.0;\n\tterms[ 1 ] = evalpoly( workspace, eta0 );\n\n\t// Now evaluate e2 and put it in terms[2]:\n\tworkspace[ 0 ] = -polyval5( s2 ) / (405.0*sc3);\n\tworkspace[ 1 ] = polyval6( s2 ) / (2592.0*sc4);\n\tworkspace[ 2 ] = -polyval7( s2 ) / (204120.0*sc5);\n\tworkspace[ 3 ] = -polyval8( s2 ) / (2099520.0*sc6);\n\tworkspace[ 4 ] = 0.0;\n\tworkspace[ 5 ] = 0.0;\n\tterms[ 2 ] = evalpoly( workspace, eta0 );\n\n\t// And e3, and put it in terms[3]:\n\tworkspace[ 0 ] = polyval9( s2 ) / (102060.0*sc5);\n\tworkspace[ 1 ] = -polyval10( s2 ) / (20995200.0*sc6);\n\tworkspace[ 2 ] = polyval11( s2 ) / (36741600.0*sc7);\n\tworkspace[ 3 ] = 0.0;\n\tworkspace[ 4 ] = 0.0;\n\tworkspace[ 5 ] = 0.0;\n\tterms[ 3 ] = evalpoly( workspace, eta0 );\n\n\t// Bring the correction terms together to evaluate eta; this is the last equation on page 151:\n\teta = evalpoly( terms, 1.0/r );\n\n\t// Now that we have eta we need to back solve for x, we seek the value of x that gives eta in Eq 3.2. The two methods used are described in section 5. Begin by defining a few variables we'll need later:\n\talpha = c / s;\n\talpha *= alpha;\n\tlu = ( -( eta*eta )/( 2.0*s2 ) ) + ln(s2) + ( c2*ln(c2)/s2 );\n\n\t// Temme doesn't specify what value to switch on here, but this seems to work pretty well:\n\tif ( abs(eta) < 0.7 ) {\n\t\t// Small eta use the expansion Temme gives in the second equation of section 5, it's a polynomial in eta:\n\t\tworkspace[ 0 ] = s2;\n\t\tworkspace[ 1 ] = sc;\n\t\tworkspace[ 2 ] = (1.0-(2.0*s2)) / 3.0;\n\t\tworkspace[ 3 ] = polyval12( s2 ) / ( 36.0*sc );\n\t\tworkspace[ 4 ] = polyval13( s2 ) / ( 270.0*sc2 );\n\t\tworkspace[ 5 ] = 0.0;\n\t\tx = evalpoly( workspace, eta );\n\t} else {\n\t\t// If eta is large we need to solve Eq 3.2 more directly, begin by getting an initial approximation for x from the last equation on page 155, this is a polynomial in u:\n\t\tu = exp( lu );\n\t\tworkspace[ 0 ] = u;\n\t\tworkspace[ 1 ] = alpha;\n\t\tworkspace[ 2 ] = 0.0;\n\t\tworkspace[ 3 ] = 3.0 * alpha * ((3.0*alpha)+1.0) / 6.0;\n\t\tworkspace[ 4 ] = 4.0 * alpha * ((4.0*alpha)+1.0) * ((4.0*alpha)+2.0) / 24.0; // eslint-disable-line max-len\n\t\tworkspace[ 5 ] = 5.0 * alpha * ((5.0*alpha)+1.0) * ((5.0*alpha)+2.0) * ((5.0*alpha)+3.0) / 120.0; // eslint-disable-line max-len\n\t\tx = evalpoly( workspace, u );\n\n\t\t// At this point we may or may not have the right answer, Eq-3.2 has two solutions for x for any given eta, however the mapping in 3.2 is 1:1 with the sign of eta and x-sin^2(theta) being the same. So we can check if we have the right root of 3.2, and if not switch x for 1-x.  This transformation is motivated by the fact that the distribution is *almost* symmetric so 1-x will be in the right ball park for the solution:\n\t\tif ( (x-s2)*eta < 0.0 ) {\n\t\t\tx = 1.0 - x;\n\t\t}\n\t}\n\t// The final step is a few Newton-Raphson iterations to clean up our approximation for x, this is pretty cheap in general, and very cheap compared to an incomplete beta evaluation. The limits set on x come from the observation that the sign of eta and x-sin^2(theta) are the same.\n\tif ( eta < 0.0 ) {\n\t\tlower = 0.0;\n\t\tupper = s2;\n\t} else {\n\t\tlower = s2;\n\t\tupper = 1.0;\n\t}\n\t// If our initial approximation is out of bounds then bisect:\n\tif ( x < lower || x > upper ) {\n\t\tx = (lower+upper) / 2.0;\n\t}\n\troots = temmeRootFinder( -lu, alpha );\n\n\t// And iterate:\n\tx = newtonRaphsonIterate( roots, x, lower, upper, 32, 100 );\n\treturn x;\n}\n\n\n// EXPORTS //\n\nexport default temme2;\n","/* eslint-disable max-statements, max-lines */\n\n/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport betainc from '@stdlib/math-base-special-betainc';\nimport expm1 from '@stdlib/math-base-special-expm1';\nimport log1p from '@stdlib/math-base-special-log1p';\nimport asin from '@stdlib/math-base-special-asin';\nimport beta from '@stdlib/math-base-special-beta';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport abs from '@stdlib/math-base-special-abs';\nimport exp from '@stdlib/math-base-special-exp';\nimport pow from '@stdlib/math-base-special-pow';\nimport sin from '@stdlib/math-base-special-sin';\nimport max from '@stdlib/math-base-special-max';\nimport min from '@stdlib/math-base-special-min';\nimport ln from '@stdlib/math-base-special-ln';\nimport FLOAT64_MIN_NORM from '@stdlib/constants-float64-smallest-normal';\nimport HALF_PI from '@stdlib/constants-float64-half-pi';\nimport EPSILON from '@stdlib/constants-float64-eps';\nimport findIBetaInvFromTDist from './find_ibeta_inv_from_t_dist.js';\nimport temme1 from './temme1.js';\nimport temme2 from './temme2.js';\nimport temme3 from './temme3.js';\nimport halleyIterate from './halley_iterate.js';\nimport ibetaRoots from './ibeta_roots.js';\n\n\n// VARIABLES //\n\nvar DIGITS = 32;\nvar MAX_ITERATIONS = 1000;\n\n// Workspace for the polynomial coefficients:\nvar terms = [ 0.0, 0.0, 0.0, 0.0, 0.0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Calculates the inverse of the incomplete beta function.\n*\n* @private\n* @param {PositiveNumber} a - function parameter\n* @param {PositiveNumber} b - function parameter\n* @param {Probability} p - function parameter\n* @param {Probability} q - probability equal to `1 - p`\n* @returns {Array} two-element array holding function value `y` and `1-y`\n*/\nfunction ibetaInvImp( a, b, p, q ) {\n\tvar digits;\n\tvar invert;\n\tvar lambda;\n\tvar lower;\n\tvar theta;\n\tvar upper;\n\tvar roots;\n\tvar maxv;\n\tvar minv;\n\tvar bet;\n\tvar ppa;\n\tvar tmp;\n\tvar xs2;\n\tvar ap1;\n\tvar bm1;\n\tvar fs;\n\tvar lx;\n\tvar ps;\n\tvar xg;\n\tvar xs;\n\tvar yp;\n\tvar a2;\n\tvar a3;\n\tvar b2;\n\tvar r;\n\tvar l;\n\tvar u;\n\tvar x;\n\tvar y;\n\n\t// The flag invert is set to true if we swap a for b and p for q, in which case the result has to be subtracted from 1:\n\tinvert = false;\n\n\t// Handle trivial cases first...\n\tif ( q === 0.0 ) {\n\t\treturn [ 1.0, 0.0 ];\n\t}\n\tif ( p === 0.0 ) {\n\t\treturn [ 0.0, 1.0 ];\n\t}\n\tif ( a === 1.0 ) {\n\t\tif ( b === 1.0 ) {\n\t\t\treturn [ p, 1.0-p ];\n\t\t}\n\t\t// Change things around so we can handle as b == 1 special case below:\n\t\ttmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\n\t\ttmp = q;\n\t\tq = p;\n\t\tp = tmp;\n\n\t\tinvert = true;\n\t}\n\t// Depending upon which approximation method we use, we may end up calculating either x or y initially (where y = 1-x):\n\tx = 0.0; // Set to a safe zero to avoid a\n\n\t// For some of the methods we can put tighter bounds on the result than simply [0,1]:\n\tlower = 0.0;\n\tupper = 1.0;\n\n\t// Student's T with b = 0.5 gets handled as a special case, swap around if the arguments are in the \"wrong\" order:\n\tif ( a === 0.5 ) {\n\t\tif ( b === 0.5 ) {\n\t\t\tx = sin( p*HALF_PI );\n\t\t\tx *= x;\n\t\t\ty = sin( q*HALF_PI );\n\t\t\ty *= y;\n\t\t\treturn [ x, y ];\n\t\t}\n\t\tif ( b > 0.5 ) {\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\n\t\t\ttmp = q;\n\t\t\tq = p;\n\t\t\tp = tmp;\n\n\t\t\tinvert = !invert;\n\t\t}\n\t}\n\t// Select calculation method for the initial estimate:\n\tif ( b === 0.5 && a >= 0.5 && p !== 1.0 ) {\n\t\t// We have a Student's T distribution:\n\t\typ = {};\n\t\tx = findIBetaInvFromTDist( a, p, yp );\n\t\ty = yp.value;\n\t}\n\telse if ( b === 1.0 ) {\n\t\tif ( p < q ) {\n\t\t\tif ( a > 1.0 ) {\n\t\t\t\tx = pow( p, 1.0/a );\n\t\t\t\ty = -expm1( ln(p) / a );\n\t\t\t} else {\n\t\t\t\tx = pow( p, 1.0/a );\n\t\t\t\ty = 1.0 - x;\n\t\t\t}\n\t\t} else {\n\t\t\tx = exp( log1p(-q) / a );\n\t\t\ty = -expm1( log1p(-q) / a );\n\t\t}\n\t\tif ( invert ) {\n\t\t\ttmp = y;\n\t\t\ty = x;\n\t\t\tx = tmp;\n\t\t}\n\t\treturn [ x, y ];\n\t}\n\telse if ( a+b > 5.0 ) {\n\t\t// When a+b is large then we can use one of Prof Temme's asymptotic expansions, begin by swapping things around so that p < 0.5, we do this to avoid cancellations errors when p is large.\n\t\tif ( p > 0.5 ) {\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\n\t\t\ttmp = q;\n\t\t\tq = p;\n\t\t\tp = tmp;\n\n\t\t\tinvert = !invert;\n\t\t}\n\t\tminv = min( a, b );\n\t\tmaxv = max( a, b );\n\t\tif ( ( sqrt(minv) > (maxv-minv) ) && minv > 5.0 ) {\n\t\t\t// When a and b differ by a small amount the curve is quite symmetrical and we can use an error function to approximate the inverse. This is the cheapest of the three Temme expansions, and the calculated value for x will never be much larger than p, so we don't have to worry about cancellation as long as p is small.\n\t\t\tx = temme1( a, b, p );\n\t\t\ty = 1.0 - x;\n\t\t} else {\n\t\t\tr = a + b;\n\t\t\ttheta = asin( sqrt( a/r ) );\n\t\t\tlambda = minv / r;\n\t\t\tif (\n\t\t\t\tlambda >= 0.2 &&\n\t\t\t\tlambda <= 0.8 &&\n\t\t\t\tr >= 10\n\t\t\t) {\n\t\t\t\t// The second error function case is the next cheapest to use, it breaks down when the result is likely to be very small, if `a+b` is also small, but we can use a cheaper expansion there in any case. As before `x` won't be much larger than `p`, so as long as `p` is small we should be free of cancellation error.\n\t\t\t\tppa = pow( p, 1.0/a );\n\t\t\t\tif ( ppa < 0.0025 && ( a+b ) < 200.0 ) {\n\t\t\t\t\tx = ppa * pow( a*beta( a, b ), 1.0/a );\n\t\t\t\t} else {\n\t\t\t\t\tx = temme2( p, r, theta );\n\t\t\t\t}\n\t\t\t\ty = 1.0 - x;\n\t\t\t} else {\n\t\t\t\t// If we get here then a and b are very different in magnitude and we need to use the third of Temme's methods which involves inverting the incomplete gamma.  This is much more expensive than the other methods.  We also can only use this method when a > b, which can lead to cancellation errors if we really want y (as we will when x is close to 1), so a different expansion is used in that case.\n\t\t\t\tif ( a < b ) {\n\t\t\t\t\ttmp = b;\n\t\t\t\t\tb = a;\n\t\t\t\t\ta = tmp;\n\n\t\t\t\t\ttmp = q;\n\t\t\t\t\tq = p;\n\t\t\t\t\tp = tmp;\n\t\t\t\t\tinvert = !invert;\n\t\t\t\t}\n\t\t\t\t// Try and compute the easy way first:\n\t\t\t\tbet = 0.0;\n\t\t\t\tif ( b < 2.0 ) {\n\t\t\t\t\tbet = beta( a, b );\n\t\t\t\t}\n\t\t\t\tif ( bet === 0.0 ) {\n\t\t\t\t\ty = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\ty = pow( b*q*bet, 1.0/b );\n\t\t\t\t\tx = 1.0 - y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( y > 1.0e-5 ) {\n\t\t\t\tx = temme3( a, b, p, q );\n\t\t\t\ty = 1.0 - x;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( a < 1.0 && b < 1.0 ) {\n\t\t// Both a and b less than 1, there is a point of inflection at xs:\n\t\txs = ( 1.0-a ) / ( 2.0-a-b );\n\n\t\t// Now we need to ensure that we start our iteration from the right side of the inflection point:\n\t\tfs = betainc( xs, a, b ) - p;\n\t\tif ( abs(fs)/p < EPSILON*3.0 ) {\n\t\t\t// The result is at the point of inflection, best just return it:\n\t\t\tif ( invert ) {\n\t\t\t\treturn [ 1.0-xs, xs ];\n\t\t\t}\n\t\t\treturn [ xs, 1.0-xs ];\n\t\t}\n\t\tif ( fs < 0.0 ) {\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\n\t\t\ttmp = q;\n\t\t\tq = p;\n\t\t\tp = tmp;\n\n\t\t\tinvert = !invert;\n\t\t\txs = 1.0 - xs;\n\t\t}\n\t\txg = pow( a*p*beta( a, b ), 1.0/a );\n\t\tx = xg / ( 1.0+xg );\n\t\ty = 1.0 / ( 1.0+xg );\n\n\t\t// And finally we know that our result is below the inflection point, so set an upper limit on our search:\n\t\tif ( x > xs ) {\n\t\t\tx = xs;\n\t\t}\n\t\tupper = xs;\n\t}\n\telse if ( a > 1.0 && b > 1.0 ) {\n\t\t// Small a and b, both greater than 1, there is a point of inflection at xs, and it's complement is xs2, we must always start our iteration from the right side of the point of inflection.\n\t\txs = ( a-1.0 ) / ( a+b-2.0 );\n\t\txs2 = ( b-1.0 ) / ( a+b-2.0 );\n\t\tps = betainc( xs, a, b ) - p;\n\n\t\tif ( ps < 0.0 ) {\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\n\t\t\ttmp = q;\n\t\t\tq = p;\n\t\t\tp = tmp;\n\n\t\t\ttmp = xs2;\n\t\t\txs2 = xs;\n\t\t\txs = tmp;\n\n\t\t\tinvert = !invert;\n\t\t}\n\t\t// Estimate x and y, using expm1 to get a good estimate for y when it's very small:\n\t\tlx = ln( p*a*beta( a, b ) ) / a;\n\t\tx = exp( lx );\n\t\ty = ( x < 0.9 ) ? 1.0-x : -expm1(lx);\n\n\t\tif ( b < a && x < 0.2 ) {\n\t\t\t// Under a limited range of circumstances we can improve our estimate for x...\n\t\t\tap1 = a - 1.0;\n\t\t\tbm1 = b - 1.0;\n\t\t\ta2 = a * a;\n\t\t\ta3 = a * a2;\n\t\t\tb2 = b * b;\n\t\t\tterms[ 0 ] = 0.0;\n\t\t\tterms[ 1 ] = 1.0;\n\t\t\tterms[ 2 ] = bm1 / ap1;\n\t\t\tap1 *= ap1;\n\t\t\tterms[ 3 ] = bm1 * (3.0*a*b + 5.0*b + a2 - a - 4.0) / (2.0 * (a+2.0) * ap1); // eslint-disable-line max-len, no-mixed-operators\n\t\t\tap1 *= (a + 1.0);\n\t\t\tterms[ 4 ] = bm1 * (33.0*a*b2 + 31.0*b2 + 8.0*a2*b2 - 30.0*a*b - 47.0*b + 11.0*a2*b + 6.0*a3*b + 18.0 + 4.0*a - a3 + a2*a2 - 10.0*a2); // eslint-disable-line max-len, no-mixed-operators\n\t\t\tterms[ 4 ] /= (3.0 * (a+3.0) * (a+2.0) * ap1);\n\t\t\tx = evalpoly( terms, x );\n\t\t}\n\t\t// Know that result is below the inflection point, so set an upper limit on search...\n\t\tif ( x > xs ) {\n\t\t\tx = xs;\n\t\t}\n\t\tupper = xs;\n\t} else {\n\t\t// Case: ( a <= 1 ) != ( b <= 1 ). If all else fails we get here, only one of a and b is above 1, and a+b is small.  Start by swapping things around so that we have a concave curve with b > a and no points of inflection in [0,1].  As long as we expect x to be small then we can use the simple (and cheap) power term to estimate x, but when we expect x to be large then this greatly underestimates x and leaves us trying to iterate \"round the corner\" which may take almost forever. We could use Temme's inverse gamma function case in that case, this works really rather well (albeit expensively) even though strictly speaking we're outside it's defined range. However it's expensive to compute, and an alternative approach which models the curve as a distorted quarter circle is much cheaper to compute, and still keeps the number of iterations required down to a reasonable level. With thanks to Prof. Temme for this suggestion.\n\t\tif ( b < a ) {\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\n\t\t\ttmp = q;\n\t\t\tq = p;\n\t\t\tp = tmp;\n\t\t\tinvert = !invert;\n\t\t}\n\t\tif ( pow( p, 1.0/a ) < 0.5 ) {\n\t\t\tx = pow( p*a*beta( a, b ), 1.0/a );\n\t\t\tif ( x === 0.0 ) {\n\t\t\t\tx = FLOAT64_MIN_NORM;\n\t\t\t}\n\t\t\ty = 1.0 - x;\n\t\t}\n\t\t// Case: pow(q, 1/b) < 0.1\n\t\telse {\n\t\t\t// Model a distorted quarter circle:\n\t\t\ty = pow( 1.0-pow( p, b*beta( a, b ) ), 1.0/b );\n\t\t\tif ( y === 0 ) {\n\t\t\t\ty = FLOAT64_MIN_NORM;\n\t\t\t}\n\t\t\tx = 1.0 - y;\n\t\t}\n\t}\n\t// Now we have a guess for x (and for y) we can set things up for iteration.  If x > 0.5 it pays to swap things round:\n\tif ( x > 0.5 ) {\n\t\ttmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\n\t\ttmp = q;\n\t\tq = p;\n\t\tp = tmp;\n\n\t\ttmp = y;\n\t\ty = x;\n\t\tx = tmp;\n\n\t\tinvert = !invert;\n\t\tl = 1.0 - upper;\n\t\tu = 1.0 - lower;\n\t\tlower = l;\n\t\tupper = u;\n\t}\n\t// Lower bound for our search:  We're not interested in denormalized answers as these tend to take up lots of iterations, given that we can't get accurate derivatives in this area (they tend to be infinite).\n\tif ( lower === 0 ) {\n\t\tif ( invert ) {\n\t\t\t// We're not interested in answers smaller than machine epsilon:\n\t\t\tlower = EPSILON;\n\t\t\tif ( x < lower ) {\n\t\t\t\tx = lower;\n\t\t\t}\n\t\t} else {\n\t\t\tlower = FLOAT64_MIN_NORM;\n\t\t}\n\t\tif ( x < lower ) {\n\t\t\tx = lower;\n\t\t}\n\t}\n\t// Figure out how many digits to iterate towards:\n\tdigits = DIGITS;\n\tif ( x < 1.0e-50 && ( a < 1.0 || b < 1.0 ) ) {\n\t\t// If we're in a region where the first derivative is very large, then we have to take care that the root-finder doesn't terminate prematurely.  We'll bump the precision up to avoid this, but we have to take care not to set the precision too high or the last few iterations will just thrash around and convergence may be slow in this case. Try 3/4 of machine epsilon:\n\t\tdigits *= 3;\n\t\tdigits /= 2;\n\t}\n\t// Now iterate, we can use either p or q as the target here depending on which is smaller:\n\troots = ibetaRoots( a, b, ( (p < q) ? p : q ), p >= q );\n\tx = halleyIterate( roots, x, lower, upper, digits, MAX_ITERATIONS );\n\n\t// Tidy up, if we \"lower\" was too high then zero is the best answer we have:\n\tif ( x === lower ) {\n\t\tx = 0.0;\n\t}\n\tif ( invert ) {\n\t\treturn [ 1.0-x, x ];\n\t}\n\treturn [ x, 1.0-x ];\n}\n\n\n// EXPORTS //\n\nexport default ibetaInvImp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -1.0;\n\t}\n\treturn -1.0 + (x * (-5.0 + (x * 5.0)));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 1.0;\n\t}\n\treturn 1.0 + (x * (21.0 + (x * (-69.0 + (x * 46.0)))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 7.0;\n\t}\n\treturn 7.0 + (x * (-2.0 + (x * (33.0 + (x * (-62.0 + (x * 31.0)))))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 25.0;\n\t}\n\treturn 25.0 + (x * (-52.0 + (x * (-17.0 + (x * (88.0 + (x * (-115.0 + (x * 46.0))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 7.0;\n\t}\n\treturn 7.0 + (x * (12.0 + (x * (-78.0 + (x * 52.0)))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -7.0;\n\t}\n\treturn -7.0 + (x * (2.0 + (x * (183.0 + (x * (-370.0 + (x * 185.0)))))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -533.0;\n\t}\n\treturn -533.0 + (x * (776.0 + (x * (-1835.0 + (x * (10240.0 + (x * (-13525.0 + (x * 5410.0))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -1579.0;\n\t}\n\treturn -1579.0 + (x * (3747.0 + (x * (-3372.0 + (x * (-15821.0 + (x * (45588.0 + (x * (-45213.0 + (x * 15071.0))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 449.0;\n\t}\n\treturn 449.0 + (x * (-1259.0 + (x * (-769.0 + (x * (6686.0 + (x * (-9260.0 + (x * 3704.0))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 63149.0;\n\t}\n\treturn 63149.0 + (x * (-151557.0 + (x * (140052.0 + (x * (-727469.0 + (x * (2239932.0 + (x * (-2251437.0 + (x * 750479.0))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 29233.0;\n\t}\n\treturn 29233.0 + (x * (-78755.0 + (x * (105222.0 + (x * (146879.0 + (x * (-1602610.0 + (x * (3195183.0 + (x * (-2554139.0 + (x * 729754.0))))))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 1.0;\n\t}\n\treturn 1.0 + (x * (-13.0 + (x * 13.0)));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 1.0;\n\t}\n\treturn 1.0 + (x * (21.0 + (x * (-69.0 + (x * 46.0)))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n/* eslint-disable no-mixed-operators, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport gammaincinv from '@stdlib/math-base-special-gammaincinv';\nimport ln from '@stdlib/math-base-special-ln';\nimport sqrt from '@stdlib/math-base-special-sqrt';\nimport SMALLEST_SUBNORMAL from '@stdlib/constants-float64-smallest-subnormal';\nimport temmeRootFinder from './root_finder.js';\nimport newtonRaphsonIterate from './newton_raphson.js';\n\n\n// MAIN //\n\n/**\n* Carries out the third method by Temme (described in section 4).\n*\n* ## References\n*\n* -   Temme, N. M. 1992. \"Incomplete Laplace Integrals: Uniform Asymptotic Expansion with Application to the Incomplete Beta Function.\" _Journal of Computational and Applied Mathematics_ 41 (1–2): 1638–63. doi:[10.1016/0377-0427(92)90244-R](https://doi.org/10.1016/0377-0427(92)90244-R).\n*\n* @private\n* @param {PositiveNumber} a - function parameter\n* @param {PositiveNumber} b - function parameter\n* @param {Probability} p - function parameter\n* @param {Probability} q - probability equal to `1-p`\n* @returns {number} function value\n*/\nfunction temme3( a, b, p, q ) {\n\tvar cross;\n\tvar roots;\n\tvar lower;\n\tvar upper;\n\tvar eta0;\n\tvar eta;\n\tvar w10;\n\tvar w12;\n\tvar w13;\n\tvar w14;\n\tvar e1;\n\tvar e2;\n\tvar e3;\n\tvar mu;\n\tvar d2;\n\tvar d3;\n\tvar d4;\n\tvar w2;\n\tvar w3;\n\tvar w4;\n\tvar w5;\n\tvar w6;\n\tvar w7;\n\tvar w8;\n\tvar w9;\n\tvar w1;\n\tvar d;\n\tvar w;\n\tvar u;\n\tvar x;\n\n\t// Begin by getting an initial approximation for the quantity eta from the dominant part of the incomplete beta:\n\tif ( p < q ) {\n\t\teta0 = gammaincinv( p, b, true );\n\t} else {\n\t\teta0 = gammaincinv( q, b, false );\n\t}\n\teta0 /= a;\n\n\t// Define the variables and powers we'll need later on:\n\tmu = b / a;\n\tw = sqrt( 1.0+mu );\n\tw2 = w * w;\n\tw3 = w2 * w;\n\tw4 = w2 * w2;\n\tw5 = w3 * w2;\n\tw6 = w3 * w3;\n\tw7 = w4 * w3;\n\tw8 = w4 * w4;\n\tw9 = w5 * w4;\n\tw10 = w5 * w5;\n\td = eta0 - mu;\n\td2 = d * d;\n\td3 = d2 * d;\n\td4 = d2 * d2;\n\tw1 = w + 1.0;\n\tw12 = w1 * w1;\n\tw13 = w1 * w12;\n\tw14 = w12 * w12;\n\n\t// Now we need to compute the perturbation error terms that convert eta0 to eta, these are all polynomials of polynomials. Probably these should be re-written to use tabulated data (see examples above), but it's less of a win in this case as we need to calculate the individual powers for the denominator terms anyway, so we might as well use them for the numerator-polynomials as well. Refer to p154-p155 for the details of these expansions:\n\te1 = (w+2.0) * (w-1.0) / (3.0*w);\n\te1 += (w3 + 9.0*w2 + 21.0*w + 5.0) * d / (36.0*w2*w1);\n\te1 -= (w4 - 13.0*w3 + 69.0*w2 + 167.0*w + 46.0) * d2 / (1620.0*w12*w3);\n\te1 -= (7.0*w5 + 21.0*w4 + 70.0*w3 + 26.0*w2 - 93.0*w - 31.0) * d3 / (6480.0*w13*w4);\n\te1 -= (75.0*w6 + 202.0*w5 + 188.0*w4 - 888.0*w3 - 1345.0*w2 + 118.0*w + 138.0) * d4 / (272160.0*w14*w5);\n\n\te2 = (28.0*w4 + 131.0*w3 + 402.0*w2 + 581.0*w + 208.0) * (w-1.0) / (1620.0*w1*w3);\n\te2 -= (35.0*w6 - 154.0*w5 - 623.0*w4 - 1636.0*w3 - 3983.0*w2 - 3514.0*w - 925.0) * d / (12960.0*w12*w4);\n\te2 -= (2132.0*w7 + 7915.0*w6 + 16821.0*w5 + 35066.0*w4 + 87490.0*w3 + 141183.0*w2 + 95993.0*w + 21640.0) * d2 / (816480.0*w5*w13);\n\te2 -= (11053.0*w8 + 53308.0*w7 + 117010.0*w6 + 163924.0*w5 + 116188.0*w4 - 258428.0*w3 - 677042.0*w2 - 481940.0*w - 105497.0) * d3 / (14696640.0*w14*w6);\n\n\te3 = -((3592.0*w7 + 8375.0*w6 - 1323.0*w5 - 29198.0*w4 - 89578.0*w3 - 154413.0*w2 - 116063.0*w - 29632.0) * (w-1.0)) / (816480.0*w5*w12);\n\te3 -= (442043.0*w9 + 2054169.0*w8 + 3803094.0*w7 + 3470754.0*w6 + 2141568.0*w5 - 2393568.0*w4 - 19904934.0*w3 - 34714674.0*w2 - 23128299.0*w - 5253353.0) * d / (146966400.0*w6*w13);\n\te3 -= (116932.0*w10 + 819281.0*w9 + 2378172.0*w8 + 4341330.0*w7 + 6806004.0*w6 + 10622748.0*w5 + 18739500.0*w4 + 30651894.0*w3 + 30869976.0*w2 + 15431867.0*w + 2919016.0) * d2 / (146966400.0*w14*w7);\n\n\t// Combine eta0 and the error terms to compute eta (Second equation p155):\n\teta = eta0 + (e1/a) + (e2/(a*a)) + (e3/(a*a*a));\n\n\t/*\n\t\tNow we need to solve Eq 4.2 to obtain x.  For any given value of\n\t\teta there are two solutions to this equation, and since the distribution\n\t\tmay be very skewed, these are not related by x ~ 1-x we used when\n\t\timplementing section 3 above.  However we know that:\n\n\t\t\tcross < x <= 1       ; iff eta < mu\n\t\t\t\tx == cross   ; iff eta == mu\n\t\t\t\t0 <= x < cross    ; iff eta > mu\n\n\t\tWhere cross == 1 / (1 + mu)\n\t\tMany thanks to Prof Temme for clarifying this point. Therefore we'll just jump straight into Newton iterations to solve Eq 4.2 using these bounds, and simple bisection as the first guess, in practice this converges pretty quickly and we only need a few digits correct anyway:\n\t*/\n\tif ( eta <= 0 ) {\n\t\teta = SMALLEST_SUBNORMAL;\n\t}\n\tu = eta - ( mu*ln(eta) ) + ( ( 1.0+mu ) * ln( 1.0+mu ) ) - mu;\n\tcross = 1.0 / ( 1.0+mu );\n\tlower = (eta < mu) ? cross : 0.0;\n\tupper = (eta < mu) ? 1.0 : cross;\n\tx = (lower+upper) / 2.0;\n\troots = temmeRootFinder( u, mu );\n\treturn newtonRaphsonIterate( roots, x, lower, upper, 32, 100 );\n}\n\n\n// EXPORTS //\n\nexport default temme3;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/ibeta_inverse.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n* Copyright Paul A. Bristow 2007.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { assign as kernelBetainc } from '@stdlib/math-base-special-kernel-betainc';\nimport abs from '@stdlib/math-base-special-abs';\nimport FLOAT64_MAX from '@stdlib/constants-float64-max';\nimport FLOAT64_MIN_NORM from '@stdlib/constants-float64-smallest-normal';\n\n\n// MAIN //\n\n/**\n* Returns a root finding function.\n*\n* @private\n* @param {PositiveNumber} a - function parameter\n* @param {PositiveNumber} b - function parameter\n* @param {Probability} target - probability value\n* @param {boolean} invert - boolean indicating whether to find the roots of the upper or lower incomplete beta function\n* @returns {Function} root finding function\n*/\nfunction ibetaRoots( a, b, target, invert ) {\n\treturn roots;\n\n\t/**\n\t* Calculates roots.\n\t*\n\t* @private\n\t* @param {number} x - input value\n\t* @returns {Array} roots\n\t*/\n\tfunction roots( x ) {\n\t\tvar buf;\n\t\tvar f1;\n\t\tvar f2;\n\t\tvar f;\n\t\tvar y;\n\n\t\ty = 1.0 - x;\n\n\t\tbuf = [ 0.0, 0.0 ];\n\t\tkernelBetainc( x, a, b, true, invert, buf, 1, 0 );\n\t\tf = buf[ 0 ] - target;\n\t\tf1 = buf[ 1 ];\n\t\tif ( invert ) {\n\t\t\tf1 = -f1;\n\t\t}\n\t\tif ( y === 0.0 ) {\n\t\t\ty = FLOAT64_MIN_NORM * 64.0;\n\t\t}\n\t\tif ( x === 0.0 ) {\n\t\t\tx = FLOAT64_MIN_NORM * 64.0;\n\t\t}\n\t\tf2 = f1 * ( -(y*a) + ( ( b-2.0 ) * x ) + 1.0 );\n\t\tif ( abs( f2 ) < y * x * FLOAT64_MAX ) {\n\t\t\tf2 /= (y * x);\n\t\t}\n\t\tif ( invert ) {\n\t\t\tf2 = -f2;\n\t\t}\n\t\t// Make sure we don't have a zero derivative:\n\t\tif ( f1 === 0.0 ) {\n\t\t\tf1 = ( ( invert ) ? -1.0 : 1.0 ) * FLOAT64_MIN_NORM * 64.0;\n\t\t}\n\t\treturn [ f, f1, f2 ];\n\t}\n}\n\n\n// EXPORTS //\n\nexport default ibetaRoots;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/tools/roots.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math-base-special-abs';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport sign from '@stdlib/math-base-special-signum';\nimport max from '@stdlib/math-base-special-max';\nimport MAX_VALUE from '@stdlib/constants-float64-max';\n\n\n// MAIN //\n\n/**\n* Performs root finding via third order Halley iteration.\n*\n* @private\n* @param {Array} fun - array of function and its first two derivatives\n* @param {number} guess - initial starting value\n* @param {number} minimum - minimum possible value for the result, used as initial lower bracket\n* @param {number} maximum - maximum possible value for the result, used as initial upper bracket\n* @param {PositiveInteger} digits - desired number of binary digits\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} function value\n*/\nfunction halleyIterate( fun, guess, minimum, maximum, digits, maxIter ) {\n\tvar convergence;\n\tvar outOfBounds;\n\tvar delta1;\n\tvar delta2;\n\tvar factor;\n\tvar result;\n\tvar f0Last;\n\tvar count;\n\tvar delta;\n\tvar denom;\n\tvar diff;\n\tvar num;\n\tvar res;\n\tvar f0;\n\tvar f1;\n\tvar f2;\n\n\tf0 = 0.0;\n\toutOfBounds = false;\n\tresult = guess;\n\tfactor = ldexp( 1.0, 1.0-digits );\n\tdelta = max( 10000000*guess, 10000000 );  // Arbitrarily large delta...\n\tf0Last = 0;\n\tdelta1 = delta;\n\tdelta2 = delta;\n\n\tcount = maxIter;\n\tdo {\n\t\tf0Last = f0;\n\t\tdelta2 = delta1;\n\t\tdelta1 = delta;\n\t\tres = fun( result );\n\t\tf0 = res[ 0 ];\n\t\tf1 = res[ 1 ];\n\t\tf2 = res[ 2 ];\n\t\tcount -= 1;\n\n\t\tif ( f0 === 0.0 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( f1 === 0.0 ) {\n\t\t\t// Oops zero derivative!!!\n\t\t\tif ( f0Last === 0.0 ) {\n\t\t\t\t// Must be the first iteration, pretend that we had a previous one at either min or max:\n\t\t\t\tif ( result === minimum ) {\n\t\t\t\t\tguess = maximum;\n\t\t\t\t} else {\n\t\t\t\t\tguess = minimum;\n\t\t\t\t}\n\t\t\t\tf0Last = fun( guess );\n\t\t\t\tdelta = guess - result;\n\t\t\t}\n\t\t\tif ( sign( f0Last ) * sign( f0 ) < 0 ) {\n\t\t\t\t// We've crossed over so move in opposite direction to last step:\n\t\t\t\tif ( delta < 0 ) {\n\t\t\t\t\tdelta = ( result-minimum ) / 2.0;\n\t\t\t\t} else {\n\t\t\t\t\tdelta = ( result-maximum ) / 2.0;\n\t\t\t\t}\n\t\t\t// Move in same direction as last step:\n\t\t\t} else if ( delta < 0 ) {\n\t\t\t\tdelta = (result-maximum) / 2.0;\n\t\t\t} else {\n\t\t\t\tdelta = (result-minimum) / 2.0;\n\t\t\t}\n\t\t} else if ( f2 === 0.0 ) {\n\t\t\tdelta = f0 / f1;\n\t\t} else {\n\t\t\tdenom = 2.0 * f0;\n\t\t\tnum = ( 2.0 * f1 ) - ( f0 * ( f2 / f1 ) );\n\t\t\tif ( abs(num) < 1.0 && ( abs(denom) >= abs(num) * MAX_VALUE ) ) {\n\t\t\t\t// Possible overflow, use Newton step:\n\t\t\t\tdelta = f0 / f1;\n\t\t\t} else {\n\t\t\t\tdelta = denom / num;\n\t\t\t}\n\t\t\tif ( delta * f1 / f0 < 0.0 ) {\n\t\t\t\t// Probably cancellation error, try a Newton step instead:\n\t\t\t\tdelta = f0 / f1;\n\t\t\t\tif ( abs(delta) > 2.0 * abs(guess) ) {\n\t\t\t\t\tdelta = ( (delta < 0.0) ? -1.0 : 1.0 ) * 2.0 * abs( guess );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconvergence = abs( delta / delta2 );\n\t\tif ( convergence > 0.8 && convergence < 2.0 ) {\n\t\t\t// Last two steps haven't converged, try bisection:\n\t\t\tdelta = ( delta > 0.0 ) ? ( result-minimum )/2.0 : ( result-maximum )/2.0; // eslint-disable-line max-len\n\t\t\tif ( abs(delta) > result ) {\n\t\t\t\tdelta = sign( delta ) * result; // Protect against huge jumps!\n\t\t\t}\n\t\t\t// Reset delta2 so that this branch will *not* be taken on the next iteration:\n\t\t\tdelta2 = delta * 3.0;\n\t\t}\n\t\tguess = result;\n\t\tresult -= delta;\n\n\t\t// Check for out of bounds step:\n\t\tif ( result < minimum ) {\n\t\t\tif (\n\t\t\t\tabs(minimum) < 1 &&\n\t\t\t\tabs(result) > 1 &&\n\t\t\t\t( MAX_VALUE / abs(result) < abs(minimum) )\n\t\t\t) {\n\t\t\t\tdiff = 1000.0;\n\t\t\t} else {\n\t\t\t\tdiff = result / minimum;\n\t\t\t}\n\t\t\tif ( abs(diff) < 1.0 ) {\n\t\t\t\tdiff = 1.0 / diff;\n\t\t\t}\n\t\t\tif ( !outOfBounds && diff > 0.0 && diff < 3.0 ) {\n\t\t\t\t// Only a small out of bounds step, let's assume that the result is probably approximately at minimum:\n\t\t\t\tdelta = 0.99 * (guess - minimum);\n\t\t\t\tresult = guess - delta;\n\t\t\t\toutOfBounds = true; // Only take this branch once!\n\t\t\t} else {\n\t\t\t\tdelta = (guess - minimum) / 2.0;\n\t\t\t\tresult = guess - delta;\n\t\t\t\tif ( result === minimum || result === maximum ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( result > maximum ) {\n\t\t\tif (\n\t\t\t\tabs(maximum) < 1.0 &&\n\t\t\t\tabs(result) > 1.0 &&\n\t\t\t\tMAX_VALUE / abs(result) < abs(maximum)\n\t\t\t) {\n\t\t\t\tdiff = 1000.0;\n\t\t\t} else {\n\t\t\t\tdiff = result / maximum;\n\t\t\t}\n\t\t\tif ( abs(diff) < 1.0 ) {\n\t\t\t\tdiff = 1.0 / diff;\n\t\t\t}\n\t\t\tif ( !outOfBounds && diff > 0.0 && diff < 3.0 ) {\n\t\t\t\t// Only a small out of bounds step, let's assume that the result is probably approximately at minimum:\n\t\t\t\tdelta = 0.99 * (guess - maximum);\n\t\t\t\tresult = guess - delta;\n\t\t\t\toutOfBounds = true; // Only take this branch once!\n\t\t\t} else {\n\t\t\t\tdelta = ( guess - maximum ) / 2.0;\n\t\t\t\tresult = guess - delta;\n\t\t\t\tif ( result === minimum || result === maximum ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update brackets:\n\t\tif ( delta > 0.0 ) {\n\t\t\tmaximum = guess;\n\t\t} else {\n\t\t\tminimum = guess;\n\t\t}\n\t} while ( count && ( abs(result * factor) < abs(delta) ) );\n\n\treturn result;\n}\n\n\n// EXPORTS //\n\nexport default halleyIterate;\n"],"names":["c0","c","inverseStudentsTBodySeries","df","u","idf","v","x","gammaDeltaRatio","sqrt","PI","polyval2","polyval3","polyval4","polyval5","polyval6","polyval7","polyval8","polyval9","evalpoly","d","inverseStudentsTTailSeries","result","div","np2","np4","np6","rn","w","pow","inverseStudentsTHill","ndf","a","b","y","erfcinv","SQRT2","HALF_PI","expm1","DF_THRESHOLD","ONE_THIRD","EXP","C","findIBetaInvFromTDist","p","py","t","tolerance","rootAlpha","invert","tmp","p0","p2","p4","r","floor","ldexp","cos","sin","acos","abs","round","inverseStudentsT","value","workspace","terms","BIG","MAX_VALUE","temmeRootFinder","ln","newtonRaphsonIterate","fun","guess","min","max","digits","maxIter","f0last","delta1","delta2","factor","count","delta","res","f0","f1","sign","ibetaInvImp","q","lambda","lower","theta","upper","roots","maxv","minv","bet","ppa","xs2","ap1","bm1","fs","lx","xg","xs","yp","a2","a3","b2","exp","log1p","z","eta0","eta2","eta","B2","B3","B","temme1","asin","beta","alpha","sc7","sc6","sc5","sc4","sc3","sc2","sc","lu","s2","c2","s","polyval1","polyval10","polyval11","polyval12","polyval13","temme2","cross","w12","w13","w14","e1","e2","e3","mu","d2","d3","w2","w3","w4","w5","w6","w7","w8","w9","w1","gammaincinv","SMALLEST_SUBNORMAL","temme3","betainc","EPSILON","FLOAT64_MIN_NORM","target","buf","f2","f","kernelBetainc","FLOAT64_MAX","ibetaRoots","minimum","maximum","convergence","outOfBounds","f0Last","denom","diff","num","halleyIterate"],"mappings":"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"}